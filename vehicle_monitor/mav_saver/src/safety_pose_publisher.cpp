/*
 * Copyright (c) 2015, Markus Achtelik, ASL, ETH Zurich, Switzerland
 * You can contact the author at <markus dot achtelik at mavt dot ethz dot ch>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "mav_saver/safety_pose_publisher.hpp"


namespace mav_saver {

//Autogenerated Message ATOS_MSG_EXTERNAL_POSITION_INPUT. Description:
//Message was found in file AC_Control.c in line 146
typedef struct
__attribute__((packed))
{
  unsigned char updateCnt;  //VT_UINT8//inc with every update//
  vector3f position;  //VT_VECTOR3F////
  float position_quality;  //VT_SINGLE//0.0=bad 1.0=best//
  unsigned short position_delay;  //VT_UINT16//in ms. Max is 400ms//
  vector3f speed;  //VT_VECTOR3F////
  float speed_quality;  //VT_SINGLE//0.0=bad 1.0=best//
  unsigned short speed_delay;  //VT_UINT16//in ms. Max is 400ms//
  quaternion orientation;  //VT_UINT16////
  unsigned int flags;  //VT_UINT32////
} ATOS_MSG_EXTERNAL_POSITION_INPUT;

#define EXT_POS_X_ACTIVE 0x01
#define EXT_POS_Y_ACTIVE 0x02
#define EXT_POS_Z_ACTIVE 0x04
#define EXT_SPEED_X_ACTIVE 0x08
#define EXT_SPEED_Y_ACTIVE 0x10
#define EXT_SPEED_Z_ACTIVE 0x20
#define EXT_QUAT_PITCH_ACTIVE 0x40
#define EXT_QUAT_ROLL_ACTIVE 0x80
#define EXT_QUAT_YAW_ACTIVE 0x0100
#define EXT_POS_DELAY_ACTIVE 0x200
#define EXT_SPEED_DELAY_ACTIVE 0x400
#define EXT_SAFETYPILOT_TAKEOVER 0x800

SafetyPosePublisher::SafetyPosePublisher(ros::NodeHandle& nh, ros::NodeHandle& private_nh):
        take_control_(false),
        serial_port_open_(false) {



  // TODO(burrimi): Move parameters to somewhere else.
  private_nh.param("baudrate", baudrate_, kDefaultBaudrate);
  private_nh.param("serial_port", port_, kDefaultSerialPort);
  private_nh.param("measurement_divisor", measurement_divisor_, kDefaultMeasurementDivisor);
  SetupSerialPort();
}


SafetyPosePublisher::SafetyPosePublisher(int baudrate, std::string port, int measurement_divisor) : measurement_divisor_(measurement_divisor),
    take_control_(false),
    serial_port_open_(false),
    aci_msg_counter_(0),
    pose_counter_(0),
    baudrate_(baudrate),
    port_(port) {
  SetupSerialPort();
}

bool SafetyPosePublisher::SetupSerialPort() {
  aci::UartPtr serial_port(new aci::Uart);
  buffer_ = serial_port;

  if (!serial_port->connect(port_, baudrate_)) {
    ROS_ERROR_STREAM("Could not connect to port " << port_ << " with baudrate " << baudrate_);
    return false;
  }

  serial_port_open_ = true;
  return true;
}

void SafetyPosePublisher::SetTakeControlFlag(bool take_control_flag) {
  take_control_ = take_control_flag;
}


void SafetyPosePublisher::SetPose(const Eigen::Vector3d& p_W_I, const Eigen::Quaterniond& q_W_I) {

  if(!serial_port_open_) {
    ROS_ERROR_STREAM_THROTTLE(1,"serial port not open");
    return;
  }
  ++pose_counter_;
  if (pose_counter_ % measurement_divisor_ != 0)
    return;

  unsigned char aci_message_type = 0x01;
  const float position_quality = 1.0; // no units. 0: bad, 1:0 excellent
  unsigned short estimated_position_delay = 20;  // ms
  unsigned char startstring[3] = { '!', '#', '!' };
  unsigned short crc = 0xFF;
  ATOS_MSG_EXTERNAL_POSITION_INPUT aci_msg;
  unsigned short aci_msg_size = sizeof(aci_msg);

  const unsigned int flags = EXT_POS_X_ACTIVE | EXT_POS_Y_ACTIVE | EXT_POS_Z_ACTIVE | EXT_QUAT_YAW_ACTIVE;

  if (take_control_) {
    aci_msg.flags = flags | EXT_SAFETYPILOT_TAKEOVER;
  }
  else {
    aci_msg.flags = flags;
  }

  aci_msg.updateCnt = aci_msg_counter_;
  ++aci_msg_counter_;

  Eigen::Quaterniond q_asc;
  Eigen::Vector3d pos_asc;

  ethzasl_mav_interface::helper::rosGeographicPoseToAsctec(p_W_I, q_W_I, &pos_asc, &q_asc);

  ROS_INFO_ONCE("sending pose ");
  ROS_INFO_THROTTLE(1, ".");

  aci_msg.position.x = pos_asc.x();
  aci_msg.position.y = pos_asc.y();
  aci_msg.position.z = pos_asc.z();

  aci_msg.orientation.w = q_asc.w();
  aci_msg.orientation.x = q_asc.x();
  aci_msg.orientation.y = q_asc.y();
  aci_msg.orientation.z = q_asc.z();

  aci_msg.position_quality = position_quality;
  aci_msg.position_delay = estimated_position_delay;

  // not used (yet), set to reasonable defaults
  aci_msg.speed.x = 0;
  aci_msg.speed.y = 0;
  aci_msg.speed.z = 0;
  aci_msg.speed_quality = 0;  // --> ignore
  aci_msg.speed_delay = 0;

  crc = UpdateCrc16(crc, &aci_message_type, 1);
  crc = UpdateCrc16(crc, &aci_msg_size, 2);
  crc = UpdateCrc16(crc, &aci_msg, aci_msg_size);

  buffer_->writeBuffer(startstring, 3);
  buffer_->writeBuffer(&aci_message_type, 1);
  buffer_->writeBuffer((uint8_t*) &aci_msg_size, 2);
  buffer_->writeBuffer((uint8_t*) &aci_msg, aci_msg_size);
  buffer_->writeBuffer((uint8_t*) &crc, 2);
}

unsigned short SafetyPosePublisher::CrcUpdate(unsigned short crc, unsigned char data) {
  data ^= (crc & 0xff);
  data ^= data << 4;

  return ((((unsigned short) data << 8) | ((crc >> 8) & 0xff)) ^ (unsigned char) (data >> 4)
      ^ ((unsigned short) data << 3));
}

unsigned short SafetyPosePublisher::UpdateCrc16(unsigned short crc, const void * data, unsigned short cnt) {
  int i = 0;
  unsigned short crcNew = crc;
  unsigned char * chrData = (unsigned char *) data;

  for (i = 0; i < cnt; i++)
    crcNew = CrcUpdate(crcNew, chrData[i]);

  return crcNew;
}


}  // namespace mav_saver
