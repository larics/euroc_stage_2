#!/usr/bin/env python

import os;
import re;
import sys;
import aslam_install_util as aiu
from argparse import ArgumentParser, RawDescriptionHelpFormatter
import argparse_config
from doctest import testfile
import traceback
import git

colored = aiu.colored

configFile = os.path.expanduser('~/.aslam_status')

usage="""

The utility prints the following for each of your aslam submodules:
 *  4  1  2  1 repository shortHeadHash (branch[tracked branch])
 -  -  -  -  -
 |  |  |  |  '------------ The number of entries in the stash (slow, optional : -S)
 |  |  |  '--------------- The number of untracked files not present in .gitignore
 |  |  '------------------ The number of commits not merged from the tracked remote.
 |  '--------------------- The number of commits not pushed to the tracked remote.
 '------------------------ A star if the repository is dirty (changes not checked in)"""
parser = ArgumentParser(description=usage, formatter_class=RawDescriptionHelpFormatter)
parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='Verbose output. Print the output of "git status"')
parser.add_argument('-H', '--context-help', dest='contextHelp', action='store_true', help='Activate context help. Print context help if available.')
parser.add_argument('-d', '--debug', dest='debug', action='store_true', help='Print debug messages')
parser.add_argument('-g', '--show-green', dest='green', action='store_true', help='Print green repositories')
parser.add_argument('-u', '--untracked', dest='untracked', action='store_true', help='Print untracked files')
parser.add_argument('-S', '--stash', dest='stash', action='store_true', help='Print the stashed column')
parser.add_argument('--sha-full', dest='shaFull', action='store_true', help='Do not abbreviate sha hash')

parser.add_argument('--ignore-untracked-dirs', dest='ignoreUntrackedDirs', action='store_true', help='Ignore untracked directories when printing untracked files (-u)')
parser.add_argument('-s', '--sort', dest='sort', action='store_true', help='Sort the submodules by name')
parser.add_argument('-f', '--fetch', dest='fetch', action='store_true', help='Fetch from upstream first')
parser.add_argument('-A', '--fetch-all', dest='fetch_all', action='store_true', help='Fetch from all remotes (implies --fetch)')
parser.add_argument('-F', '--fastforward', dest='fastforward', action='store_true', help='Fastforward merge')
parser.add_argument('-p', '--pull', dest='pull', action='store_true', help='Pull')
parser.add_argument('--maxdepth', dest='maxdepth', type=int, help='A maximal scan depth for the crawled directories. Defaults to 1, which means just the direct subdirectories.', default=1, metavar="MAXDEPTH")
parser.add_argument('-i', '--include', dest='include', action="append", help='A positive filter on the submodules'' names', metavar="REGEXP")
parser.add_argument('-I', '--include-marker', dest='includeMarker', action="append", help='A positive filter that tests for existence of file MARKERFILE in the git working copy.', metavar="MARKERFILE")
parser.add_argument('-e', '--exclude', dest='exclude', action="append", help='A negative filter on the submodules'' names', metavar="REGEXP")
parser.add_argument('-E', '--exclude-marker', dest='excludeMarker', action="append", help='A negative filter that tests for existence of file MARKERFILE in the git working copy.', metavar="MARKERFILE")
parser.add_argument('-n', '--nested', dest='nested', action='store_true', help='If set git working copies are scanned for nested working copies.')
parser.add_argument('--save', dest='saveOptions', action='store_true', help='Save current options to the configuration file (%s) [EXPERIMENTAL FEATURE].' % (configFile))
parser.add_argument("directory", nargs='*', help="Directory to be scanned.")

options = parser.parse_args()

argparse_config.read_config_file(parser, configFile)
options = parser.parse_args()

#uniquify all lists in options
for k, o in options.__dict__.iteritems(): 
    if isinstance(o, list):
        s = set([])
        out = []
        for item in o :
            if item not in s : out.append(item); s.add(item);
        options.__dict__[k] = out;

if options.debug:
    print str(options).replace('Namespace', 'Options')

if options.saveOptions:
    options.saveOptions = False;
    f = open(configFile, "w")
    text = argparse_config.generate_config(parser, options, section='default', only_non_defaults=True);
    f.write(text)
    f.close()
    print "Wrote the following into %s :\n" % configFile , text 
    sys.exit(0);

infoColor='blue'
print colored(""" .-------------------------- A star if the repository is dirty (changes not checked in)
 |   .---------------------- The number of commits not pushed to the tracked remote.
 |   |   .------------------ The number of commits not merged from the tracked remote.
 |   |   |   .-------------- The number of untracked files not present in .gitignore""",infoColor)

if(options.stash):
    print colored(" |   |   |   |   .---------- The number of entries in the stash", infoColor)

class PatternFilter(object):
    def __init__(self, pattern, invert):
        self.invert  = invert;
        self.pattern = re.compile(pattern) if pattern else False;
        if (pattern):
            try: 
                self.pattern = re.compile(pattern) if pattern else False;
            except:
                print "error in regular expression {}.", pattern;
    def match(self, name, path):
        if(not self.pattern): return True;
        return self.invert != bool(self.pattern.search(name));

class FileFilter(object):
    def __init__(self, testFile, invert):
        self.invert  = invert;
        self.testFile = testFile;
    def match(self, name, path):
        return self.invert != os.path.exists(os.path.join(path, self.testFile));

class OredFilters(object):
    def __init__(self, filters):
        self.filters  = filters;
    def match(self, name, path):
        for f in self.filters:
            if(f.match(name, path)) : return True; 
        return False;

includes = []
filters = []
if(options.exclude): 
    for e in options.exclude : filters.append(PatternFilter(e, True));
if(options.include): 
    for i in options.include : includes.append(PatternFilter(i, False));
if(options.excludeMarker): 
    for e in options.excludeMarker : filters.append(FileFilter(e, True));
if(options.includeMarker): 
    for i in options.includeMarker : includes.append(FileFilter(i, False));

if(includes): filters.append(OredFilters(includes));

if(options.directory):
    directory = options.directory
else:
    directory = '.'

submodules = aiu.findGitsInDirectories(directory, options.maxdepth, filters, options.nested);

for name, path in sorted(submodules.iteritems()) if options.sort else submodules.iteritems() :
    if options.debug:
        print "Looking at module {0} on path {1}".format(name,path)
        
    repo = aiu.Repo(name, path)
    if options.fetch:
        try:
            repo.fetch()
        except Exception as e:
            print colored("Fetching {0} failed:{1}".format(name, str(e)), 'red')
    if options.fetch_all:
        try:
            repo.fetchAll()
        except Exception as e:
            print colored("Fetching all for {0} failed:{1}".format(name, str(e)), 'red')

    color='green'
    
    if options.pull:
        try:
            repo.pull()
        except git.GitCommandError as e:
            print colored("Pull on repository {0} failed.\n{1}".format(name,e), 'red')

    # This line gets all commits that have not
    # been merged from upstream
    unmerged = repo.getUnmergedCommits()
    if len(unmerged) > 0:
        if options.fastforward and unmerged:
            try:
                repo.fastforward()
                unmerged = repo.getUnmergedCommits()
                if len(unmerged) > 0:
                    color = 'cyan'
            except git.GitCommandError as e:
                print colored("Merging fast forward {0} failed.\n{1}".format(name,e), 'red')
                
                color = 'cyan'
        else:
            color = 'cyan'

    # This line gets all commits that have not
    # been pushed upstream
    unpushed = repo.getUnpushedCommits(options.contextHelp)

    untracked = repo.getUntrackedFiles(options.ignoreUntrackedDirs)

    unpushedTag = '  .'
    if len(unpushed) > 0:
        unpushedTag = "{0:3}".format(len(unpushed))
        color = 'yellow'
    unmergedTag = '  .'
    if len(unmerged) > 0:
        unmergedTag = "{0:3}".format(len(unmerged))
    untrackedTag = '  .'
    if len(untracked) > 0:
        untrackedTag = "{0:3}".format(len(untracked))
        # Warn if there are untracked files
        color = 'yellow'

    tagsList = [unpushedTag, unmergedTag, untrackedTag]

    if(options.stash):
        stashed = repo.getStashed();
        stashedTag = '  .'
        if len(stashed) > 0:
            stashedTag = "{0:3}".format(len(stashed))
            color = 'yellow'
        tagsList.append(stashedTag)
    
    dirty=' '
    if repo.isDirty():
        color = 'red'
        dirty='*'

    
    tags = ' '.join(tagsList);
    
    shaPrecision = "" if options.shaFull else ":6.6"
    if color != 'green' or options.green:
        print colored((" {0} {1} {2:40}{3%s} ({4}[{5}])" % shaPrecision).format(dirty, tags, name, repo.hexSha(), repo.activeBranch(), repo.trackedBranch()), color)
        if options.verbose and repo.isDirty():
            print repo.status()
            print ""
        if len(untracked) > 0 and options.untracked:
            print "Untracked files:"
            for un in untracked:
                print un
        if options.debug:
            if len(unpushed) > 0:
                print "Unpushed commits:\n{0}".format(unpushed)
            if len(untracked) > 0:
                print "Untracked files:\n{0}".format(untracked)
